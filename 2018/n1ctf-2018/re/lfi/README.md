给的是luajit的字节码文件，用工具ljd进行反编译（原本的代码有bug，需要修补一下才能正常反编译），可以看到func1用到了一个`11*16*256`数组和一个`4*256*4`数组，对一个给定的16字节明文（havefun...）进行了对称加密，猜测是白盒AES加密。func2是即时加载的，有一个很长的数组逐个和42异或，得到一个另一个luac文件的内容，符号给的很清晰，逆向可知func2是以输入作为key对一个给定的16字节明文（依然是havefun那个）进行AES加密。于是本题的目标就是实现AES key schedule的逆运算。先从xortable（`11*16*256`数组）恢复出第二轮的轮密钥，由于第一轮的轮密钥是全0，所以事实上第二轮的轮密钥就是flag字符的一个重排，于是再排回来就是flag了
